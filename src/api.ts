/**
 * EveryQA Public API
 * Documentation for EveryQA Public API # Authentication  EveryQA Public API offers only one form of authentication: - Bearer API Token
 *
 * OpenAPI spec version: 0.1
 * Contact: support@everyqa.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from 'url';
import { Configuration } from './configuration';
import portableFetch from 'portable-fetch';

const BASE_PATH = 'https://api.everyqa.io/v1'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export type FetchAPI = (url: string, init?: any) => Promise<Response>;

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration!: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch as FetchAPI) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = 'RequiredError';
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface ActionAction
 */
export interface ActionAction {
    /**
     *
     * @type {number}
     * @memberof ActionAction
     */
    created_at?: number;
    /**
     *
     * @type {string}
     * @memberof ActionAction
     */
    created_by?: string;
    /**
     *
     * @type {number}
     * @memberof ActionAction
     */
    deleted_at?: number;
    /**
     *
     * @type {number}
     * @memberof ActionAction
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof ActionAction
     */
    notes?: string;
    /**
     *
     * @type {number}
     * @memberof ActionAction
     */
    status_id?: number;
    /**
     *
     * @type {number}
     * @memberof ActionAction
     */
    test_id?: number;
    /**
     *
     * @type {number}
     * @memberof ActionAction
     */
    updated_at?: number;
}

/**
 *
 * @export
 * @interface ExecutionExecution
 */
export interface ExecutionExecution {
    /**
     *
     * @type {string}
     * @memberof ExecutionExecution
     */
    assigned_to?: string;
    /**
     *
     * @type {number}
     * @memberof ExecutionExecution
     */
    case_id?: number;
    /**
     *
     * @type {string}
     * @memberof ExecutionExecution
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof ExecutionExecution
     */
    created_by?: string;
    /**
     *
     * @type {string}
     * @memberof ExecutionExecution
     */
    deleted_at?: string;
    /**
     *
     * @type {number}
     * @memberof ExecutionExecution
     */
    estimate?: number;
    /**
     *
     * @type {string}
     * @memberof ExecutionExecution
     */
    expected_result?: string;
    /**
     *
     * @type {number}
     * @memberof ExecutionExecution
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof ExecutionExecution
     */
    inner_id?: number;
    /**
     *
     * @type {string}
     * @memberof ExecutionExecution
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof ExecutionExecution
     */
    network_id?: string;
    /**
     *
     * @type {number}
     * @memberof ExecutionExecution
     */
    order?: number;
    /**
     *
     * @type {string}
     * @memberof ExecutionExecution
     */
    preconditions?: string;
    /**
     *
     * @type {string}
     * @memberof ExecutionExecution
     */
    priority?: string;
    /**
     *
     * @type {string}
     * @memberof ExecutionExecution
     */
    project_id?: string;
    /**
     *
     * @type {number}
     * @memberof ExecutionExecution
     */
    run_id?: number;
    /**
     *
     * @type {number}
     * @memberof ExecutionExecution
     */
    section_id?: number;
    /**
     *
     * @type {string}
     * @memberof ExecutionExecution
     */
    status_changed_at?: string;
    /**
     *
     * @type {number}
     * @memberof ExecutionExecution
     */
    status_id?: number;
    /**
     *
     * @type {Array<TestcaseCaseStep>}
     * @memberof ExecutionExecution
     */
    steps?: TestcaseCaseStep[];
    /**
     *
     * @type {string}
     * @memberof ExecutionExecution
     */
    updated_at?: string;
}

/**
 *
 * @export
 * @interface ModelAPIError
 */
export interface ModelAPIError {
    /**
     *
     * @type {string}
     * @memberof ModelAPIError
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof ModelAPIError
     */
    status?: string;
}

/**
 *
 * @export
 * @interface ModelAddActionToTestDto
 */
export interface ModelAddActionToTestDto {
    /**
     *
     * @type {string}
     * @memberof ModelAddActionToTestDto
     */
    notes?: string;
    /**
     *
     * @type {number}
     * @memberof ModelAddActionToTestDto
     */
    status_id?: number;
}

/**
 *
 * @export
 * @interface ModelResultToTestDto
 */
export interface ModelResultToTestDto {
    /**
     *
     * @type {number}
     * @memberof ModelResultToTestDto
     */
    run_id?: number;
    /**
     *
     * @type {string}
     * @memberof ModelResultToTestDto
     */
    notes?: string;
    /**
     *
     * @type {number}
     * @memberof ModelResultToTestDto
     */
    status_id?: number;
}

/**
 *
 * @export
 * @interface ProjectProjectDto
 */
export interface ProjectProjectDto {
    /**
     *
     * @type {string}
     * @memberof ProjectProjectDto
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof ProjectProjectDto
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof ProjectProjectDto
     */
    network_id?: string;
    /**
     *
     * @type {string}
     * @memberof ProjectProjectDto
     */
    sprint_type?: string;
    /**
     *
     * @type {string}
     * @memberof ProjectProjectDto
     */
    type?: string;
}

/**
 *
 * @export
 * @interface TestcaseCase
 */
export interface TestcaseCase {
    /**
     *
     * @type {string}
     * @memberof TestcaseCase
     */
    author?: string;
    /**
     *
     * @type {string}
     * @memberof TestcaseCase
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof TestcaseCase
     */
    deleted_at?: string;
    /**
     *
     * @type {number}
     * @memberof TestcaseCase
     */
    estimate?: number;
    /**
     *
     * @type {string}
     * @memberof TestcaseCase
     */
    expected_result?: string;
    /**
     *
     * @type {number}
     * @memberof TestcaseCase
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof TestcaseCase
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof TestcaseCase
     */
    network_id?: string;
    /**
     *
     * @type {number}
     * @memberof TestcaseCase
     */
    order?: number;
    /**
     *
     * @type {string}
     * @memberof TestcaseCase
     */
    preconditions?: string;
    /**
     *
     * @type {string}
     * @memberof TestcaseCase
     */
    priority?: string;
    /**
     *
     * @type {string}
     * @memberof TestcaseCase
     */
    project_id?: string;
    /**
     *
     * @type {number}
     * @memberof TestcaseCase
     */
    section_id?: number;
    /**
     *
     * @type {Array<TestcaseCaseStep>}
     * @memberof TestcaseCase
     */
    steps?: TestcaseCaseStep[];
    /**
     *
     * @type {string}
     * @memberof TestcaseCase
     */
    updated_at?: string;
}

/**
 *
 * @export
 * @interface TestcaseCaseStep
 */
export interface TestcaseCaseStep {
    /**
     *
     * @type {string}
     * @memberof TestcaseCaseStep
     */
    desc?: string;
    /**
     *
     * @type {string}
     * @memberof TestcaseCaseStep
     */
    expectedResult?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof TestcaseCaseStep
     */
    imgSrc?: string[];
}

/**
 *
 * @export
 * @interface TestrunCreateTestRunDto
 */
export interface TestrunCreateTestRunDto {
    /**
     *
     * @type {string}
     * @memberof TestrunCreateTestRunDto
     */
    assign_to?: string;
    /**
     *
     * @type {string}
     * @memberof TestrunCreateTestRunDto
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof TestrunCreateTestRunDto
     */
    sprint_id?: number;
}

/**
 *
 * @export
 * @interface TestrunTestRun
 */
export interface TestrunTestRun {
    /**
     *
     * @type {string}
     * @memberof TestrunTestRun
     */
    assigned_to?: string;
    /**
     *
     * @type {string}
     * @memberof TestrunTestRun
     */
    completed_at?: string;
    /**
     *
     * @type {string}
     * @memberof TestrunTestRun
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof TestrunTestRun
     */
    created_by?: string;
    /**
     *
     * @type {string}
     * @memberof TestrunTestRun
     */
    deleted_at?: string;
    /**
     *
     * @type {number}
     * @memberof TestrunTestRun
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof TestrunTestRun
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof TestrunTestRun
     */
    network_id?: string;
    /**
     *
     * @type {string}
     * @memberof TestrunTestRun
     */
    project_id?: string;
    /**
     *
     * @type {number}
     * @memberof TestrunTestRun
     */
    sprint_id?: number;
    /**
     *
     * @type {string}
     * @memberof TestrunTestRun
     */
    status?: string;
    /**
     *
     * @type {string}
     * @memberof TestrunTestRun
     */
    updated_at?: string;
}

/**
 *
 * @export
 * @interface TestrunUpdateRunDto
 */
export interface TestrunUpdateRunDto {
    /**
     *
     * @type {string}
     * @memberof TestrunUpdateRunDto
     */
    assign_to?: string;
    /**
     *
     * @type {string}
     * @memberof TestrunUpdateRunDto
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof TestrunUpdateRunDto
     */
    sprint_id?: number;
    /**
     *
     * @type {string}
     * @memberof TestrunUpdateRunDto
     */
    status?: string;
}

/**
 *
 * @export
 * @interface UserUser
 */
export interface UserUser {
    /**
     *
     * @type {string}
     * @memberof UserUser
     */
    created?: string;
    /**
     *
     * @type {string}
     * @memberof UserUser
     */
    first_name?: string;
    /**
     *
     * @type {boolean}
     * @memberof UserUser
     */
    is_active?: boolean;
    /**
     *
     * @type {string}
     * @memberof UserUser
     */
    last_name?: string;
    /**
     *
     * @type {string}
     * @memberof UserUser
     */
    network_id?: string;
    /**
     *
     * @type {number}
     * @memberof UserUser
     */
    role_id?: number;
    /**
     *
     * @type {string}
     * @memberof UserUser
     */
    user_id?: string;
}


/**
 * ActionApi - fetch parameter creator
 *
 * @export
 */
export const ActionApiFetchParamCreator = function(configuration?: Configuration) {
    return {
        /**
         * Create test action by caseID
         *
         * @summary Create test action by Case ID
         * @param {string} project_id ID of project
         * @param {number} case_id ID of run
         * @param {ModelResultToTestDto} body Result Model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionByCaseId(project_id: string, case_id: number, body: ModelResultToTestDto, options: any = {}): FetchArgs {
            // verify required parameter 'project_id' is not null or undefined
            if (project_id === null || project_id === undefined) {
                throw new RequiredError('project_id','Required parameter project_id was null or undefined when calling createActionByCaseId.');
            }
            // verify required parameter 'case_id' is not null or undefined
            if (case_id === null || case_id === undefined) {
                throw new RequiredError('case_id','Required parameter case_id was null or undefined when calling createActionByCaseId.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createActionByCaseId.');
            }
            const localVarPath = '/projects/{project_id}/cases/{case_id}/actions'
                .replace(`{${'project_id'}}`, encodeURIComponent(String(project_id)))
                .replace(`{${'case_id'}}`, encodeURIComponent(String(case_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>'ModelResultToTestDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || '');

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create test action by  testID
         *
         * @summary Create test action by Test ID
         * @param {string} project_id ID of project
         * @param {number} run_id ID of run
         * @param {number} test_id ID of test
         * @param {ModelAddActionToTestDto} body Get List of Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionByTestId(project_id: string, run_id: number, test_id: number, body: ModelAddActionToTestDto, options: any = {}): FetchArgs {
            // verify required parameter 'project_id' is not null or undefined
            if (project_id === null || project_id === undefined) {
                throw new RequiredError('project_id','Required parameter project_id was null or undefined when calling createActionByTestId.');
            }
            // verify required parameter 'run_id' is not null or undefined
            if (run_id === null || run_id === undefined) {
                throw new RequiredError('run_id','Required parameter run_id was null or undefined when calling createActionByTestId.');
            }
            // verify required parameter 'test_id' is not null or undefined
            if (test_id === null || test_id === undefined) {
                throw new RequiredError('test_id','Required parameter test_id was null or undefined when calling createActionByTestId.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createActionByTestId.');
            }
            const localVarPath = '/projects/{project_id}/runs/{run_id}/tests/{test_id}/actions'
                .replace(`{${'project_id'}}`, encodeURIComponent(String(project_id)))
                .replace(`{${'run_id'}}`, encodeURIComponent(String(run_id)))
                .replace(`{${'test_id'}}`, encodeURIComponent(String(test_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>'ModelAddActionToTestDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || '');

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionApi - functional programming interface
 *
 * @export
 */
export const ActionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create test action by caseID
         *
         * @summary Create test action by Case ID
         * @param {string} project_id ID of project
         * @param {number} case_id ID of run
         * @param {ModelResultToTestDto} body Result Model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionByCaseId(project_id: string, case_id: number, body: ModelResultToTestDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionAction> {
            const localVarFetchArgs = ActionApiFetchParamCreator(configuration).createActionByCaseId(project_id, case_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Create test action by  testID
         *
         * @summary Create test action by Test ID
         * @param {string} project_id ID of project
         * @param {number} run_id ID of run
         * @param {number} test_id ID of test
         * @param {ModelAddActionToTestDto} body Get List of Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionByTestId(project_id: string, run_id: number, test_id: number, body: ModelAddActionToTestDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionAction> {
            const localVarFetchArgs = ActionApiFetchParamCreator(configuration).createActionByTestId(project_id, run_id, test_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    };
};

/**
 * ActionApi - factory interface
 *
 * @export
 */
export const ActionApiFactory = function(configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create test action by caseID
         *
         * @summary Create test action by Case ID
         * @param {string} project_id ID of project
         * @param {number} case_id ID of run
         * @param {ModelResultToTestDto} body Result Model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionByCaseId(project_id: string, case_id: number, body: ModelResultToTestDto, options?: any) {
            return ActionApiFp(configuration).createActionByCaseId(project_id, case_id, body, options)(fetch, basePath);
        },
        /**
         * Create test action by  testID
         *
         * @summary Create test action by Test ID
         * @param {string} project_id ID of project
         * @param {number} run_id ID of run
         * @param {number} test_id ID of test
         * @param {ModelAddActionToTestDto} body Get List of Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionByTestId(project_id: string, run_id: number, test_id: number, body: ModelAddActionToTestDto, options?: any) {
            return ActionApiFp(configuration).createActionByTestId(project_id, run_id, test_id, body, options)(fetch, basePath);
        },
    };
};

/**
 * ActionApi - object-oriented interface
 *
 * @export
 * @class ActionApi
 * @extends {BaseAPI}
 */
export class ActionApi extends BaseAPI {
    /**
     * Create test action by caseID
     *
     * @summary Create test action by Case ID
     * @param {string} project_id ID of project
     * @param {number} case_id ID of run
     * @param {ModelResultToTestDto} body Result Model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public createActionByCaseId(project_id: string, case_id: number, body: ModelResultToTestDto, options?: any) {
        return ActionApiFp(this.configuration).createActionByCaseId(project_id, case_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Create test action by  testID
     *
     * @summary Create test action by Test ID
     * @param {string} project_id ID of project
     * @param {number} run_id ID of run
     * @param {number} test_id ID of test
     * @param {ModelAddActionToTestDto} body Get List of Run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public createActionByTestId(project_id: string, run_id: number, test_id: number, body: ModelAddActionToTestDto, options?: any) {
        return ActionApiFp(this.configuration).createActionByTestId(project_id, run_id, test_id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * CasesApi - fetch parameter creator
 *
 * @export
 */
export const CasesApiFetchParamCreator = function(configuration?: Configuration) {
    return {
        /**
         * Get list of test-run by projectID
         *
         * @summary Get list of test cases
         * @param {string} project_id ID of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCasesByProjectId(project_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'project_id' is not null or undefined
            if (project_id === null || project_id === undefined) {
                throw new RequiredError('project_id','Required parameter project_id was null or undefined when calling getAllCasesByProjectId.');
            }
            const localVarPath = '/projects/{project_id}/cases'
                .replace(`{${'project_id'}}`, encodeURIComponent(String(project_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get test case info by caseID
         *
         * @summary Get test case info
         * @param {number} case_id ID of case to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCaseByCaseId(case_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'case_id' is not null or undefined
            if (case_id === null || case_id === undefined) {
                throw new RequiredError('case_id','Required parameter case_id was null or undefined when calling getCaseByCaseId.');
            }
            const localVarPath = '/projects/{project_id}/cases/{case_id}'
                .replace(`{${'case_id'}}`, encodeURIComponent(String(case_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * CasesApi - functional programming interface
 *
 * @export
 */
export const CasesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get list of test-run by projectID
         *
         * @summary Get list of test cases
         * @param {string} project_id ID of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCasesByProjectId(project_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TestcaseCase[]> {
            const localVarFetchArgs = CasesApiFetchParamCreator(configuration).getAllCasesByProjectId(project_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get test case info by caseID
         *
         * @summary Get test case info
         * @param {number} case_id ID of case to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCaseByCaseId(case_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TestcaseCase> {
            const localVarFetchArgs = CasesApiFetchParamCreator(configuration).getCaseByCaseId(case_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    };
};

/**
 * CasesApi - factory interface
 *
 * @export
 */
export const CasesApiFactory = function(configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get list of test-run by projectID
         *
         * @summary Get list of test cases
         * @param {string} project_id ID of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCasesByProjectId(project_id: string, options?: any) {
            return CasesApiFp(configuration).getAllCasesByProjectId(project_id, options)(fetch, basePath);
        },
        /**
         * Get test case info by caseID
         *
         * @summary Get test case info
         * @param {number} case_id ID of case to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCaseByCaseId(case_id: number, options?: any) {
            return CasesApiFp(configuration).getCaseByCaseId(case_id, options)(fetch, basePath);
        },
    };
};

/**
 * CasesApi - object-oriented interface
 *
 * @export
 * @class CasesApi
 * @extends {BaseAPI}
 */
export class CasesApi extends BaseAPI {
    /**
     * Get list of test-run by projectID
     *
     * @summary Get list of test cases
     * @param {string} project_id ID of project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public getAllCasesByProjectId(project_id: string, options?: any) {
        return CasesApiFp(this.configuration).getAllCasesByProjectId(project_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get test case info by caseID
     *
     * @summary Get test case info
     * @param {number} case_id ID of case to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public getCaseByCaseId(case_id: number, options?: any) {
        return CasesApiFp(this.configuration).getCaseByCaseId(case_id, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectApi - fetch parameter creator
 *
 * @export
 */
export const ProjectApiFetchParamCreator = function(configuration?: Configuration) {
    return {
        /**
         * Get project info by projectID
         *
         * @summary Get project info
         * @param {string} project_id ID of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectById(project_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'project_id' is not null or undefined
            if (project_id === null || project_id === undefined) {
                throw new RequiredError('project_id','Required parameter project_id was null or undefined when calling getProjectById.');
            }
            const localVarPath = '/projects/{project_id}'
                .replace(`{${'project_id'}}`, encodeURIComponent(String(project_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ProjectApi - functional programming interface
 *
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get project info by projectID
         *
         * @summary Get project info
         * @param {string} project_id ID of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectById(project_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectProjectDto> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).getProjectById(project_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    };
};

/**
 * ProjectApi - factory interface
 *
 * @export
 */
export const ProjectApiFactory = function(configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get project info by projectID
         *
         * @summary Get project info
         * @param {string} project_id ID of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectById(project_id: string, options?: any) {
            return ProjectApiFp(configuration).getProjectById(project_id, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 *
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * Get project info by projectID
     *
     * @summary Get project info
     * @param {string} project_id ID of project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public getProjectById(project_id: string, options?: any) {
        return ProjectApiFp(this.configuration).getProjectById(project_id, options)(this.fetch, this.basePath);
    }

}

/**
 * RunsApi - fetch parameter creator
 *
 * @export
 */
export const RunsApiFetchParamCreator = function(configuration?: Configuration) {
    return {
        /**
         * Close test run
         *
         * @summary Close test run
         * @param {string} project_id ID of project
         * @param {number} run_id ID of run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeRunById(project_id: string, run_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'project_id' is not null or undefined
            if (project_id === null || project_id === undefined) {
                throw new RequiredError('project_id','Required parameter project_id was null or undefined when calling closeRunById.');
            }
            // verify required parameter 'run_id' is not null or undefined
            if (run_id === null || run_id === undefined) {
                throw new RequiredError('run_id','Required parameter run_id was null or undefined when calling closeRunById.');
            }
            const localVarPath = '/projects/{project_id}/runs/{run_id}/close'
                .replace(`{${'project_id'}}`, encodeURIComponent(String(project_id)))
                .replace(`{${'run_id'}}`, encodeURIComponent(String(run_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create test run
         *
         * @summary Create test run
         * @param {string} project_id ID of project
         * @param {TestrunCreateTestRunDto} body Close Run Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(project_id: string, body: TestrunCreateTestRunDto, options: any = {}): FetchArgs {
            // verify required parameter 'project_id' is not null or undefined
            if (project_id === null || project_id === undefined) {
                throw new RequiredError('project_id','Required parameter project_id was null or undefined when calling createRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRun.');
            }
            const localVarPath = '/projects/{project_id}/runs'
                .replace(`{${'project_id'}}`, encodeURIComponent(String(project_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>'TestrunCreateTestRunDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || '');

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of test-run by projectID
         *
         * @summary Get list of test-run
         * @param {string} project_id ID of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRunsByProjectId(project_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'project_id' is not null or undefined
            if (project_id === null || project_id === undefined) {
                throw new RequiredError('project_id','Required parameter project_id was null or undefined when calling getAllRunsByProjectId.');
            }
            const localVarPath = '/projects/{project_id}/runs'
                .replace(`{${'project_id'}}`, encodeURIComponent(String(project_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get run info by ID
         *
         * @summary Get run info by ID
         * @param {string} project_id ID of project
         * @param {number} run_id ID of run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunById(project_id: string, run_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'project_id' is not null or undefined
            if (project_id === null || project_id === undefined) {
                throw new RequiredError('project_id','Required parameter project_id was null or undefined when calling getRunById.');
            }
            // verify required parameter 'run_id' is not null or undefined
            if (run_id === null || run_id === undefined) {
                throw new RequiredError('run_id','Required parameter run_id was null or undefined when calling getRunById.');
            }
            const localVarPath = '/projects/{project_id}/runs/{run_id}'
                .replace(`{${'project_id'}}`, encodeURIComponent(String(project_id)))
                .replace(`{${'run_id'}}`, encodeURIComponent(String(run_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update test-run info by ID
         *
         * @summary Update test-run info
         * @param {string} project_id ID of project
         * @param {number} run_id ID of run
         * @param {TestrunUpdateRunDto} body Update Run Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunById(project_id: string, run_id: number, body: TestrunUpdateRunDto, options: any = {}): FetchArgs {
            // verify required parameter 'project_id' is not null or undefined
            if (project_id === null || project_id === undefined) {
                throw new RequiredError('project_id','Required parameter project_id was null or undefined when calling updateRunById.');
            }
            // verify required parameter 'run_id' is not null or undefined
            if (run_id === null || run_id === undefined) {
                throw new RequiredError('run_id','Required parameter run_id was null or undefined when calling updateRunById.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRunById.');
            }
            const localVarPath = '/projects/{project_id}/runs/{run_id}'
                .replace(`{${'project_id'}}`, encodeURIComponent(String(project_id)))
                .replace(`{${'run_id'}}`, encodeURIComponent(String(run_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>'TestrunUpdateRunDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || '');

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * RunsApi - functional programming interface
 *
 * @export
 */
export const RunsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Close test run
         *
         * @summary Close test run
         * @param {string} project_id ID of project
         * @param {number} run_id ID of run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeRunById(project_id: string, run_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TestrunTestRun> {
            const localVarFetchArgs = RunsApiFetchParamCreator(configuration).closeRunById(project_id, run_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Create test run
         *
         * @summary Create test run
         * @param {string} project_id ID of project
         * @param {TestrunCreateTestRunDto} body Close Run Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(project_id: string, body: TestrunCreateTestRunDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TestrunTestRun> {
            const localVarFetchArgs = RunsApiFetchParamCreator(configuration).createRun(project_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get list of test-run by projectID
         *
         * @summary Get list of test-run
         * @param {string} project_id ID of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRunsByProjectId(project_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TestrunTestRun[]> {
            const localVarFetchArgs = RunsApiFetchParamCreator(configuration).getAllRunsByProjectId(project_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get run info by ID
         *
         * @summary Get run info by ID
         * @param {string} project_id ID of project
         * @param {number} run_id ID of run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunById(project_id: string, run_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TestrunTestRun> {
            const localVarFetchArgs = RunsApiFetchParamCreator(configuration).getRunById(project_id, run_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Update test-run info by ID
         *
         * @summary Update test-run info
         * @param {string} project_id ID of project
         * @param {number} run_id ID of run
         * @param {TestrunUpdateRunDto} body Update Run Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunById(project_id: string, run_id: number, body: TestrunUpdateRunDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TestrunTestRun> {
            const localVarFetchArgs = RunsApiFetchParamCreator(configuration).updateRunById(project_id, run_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    };
};

/**
 * RunsApi - factory interface
 *
 * @export
 */
export const RunsApiFactory = function(configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Close test run
         *
         * @summary Close test run
         * @param {string} project_id ID of project
         * @param {number} run_id ID of run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeRunById(project_id: string, run_id: number, options?: any) {
            return RunsApiFp(configuration).closeRunById(project_id, run_id, options)(fetch, basePath);
        },
        /**
         * Create test run
         *
         * @summary Create test run
         * @param {string} project_id ID of project
         * @param {TestrunCreateTestRunDto} body Close Run Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(project_id: string, body: TestrunCreateTestRunDto, options?: any) {
            return RunsApiFp(configuration).createRun(project_id, body, options)(fetch, basePath);
        },
        /**
         * Get list of test-run by projectID
         *
         * @summary Get list of test-run
         * @param {string} project_id ID of project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRunsByProjectId(project_id: string, options?: any) {
            return RunsApiFp(configuration).getAllRunsByProjectId(project_id, options)(fetch, basePath);
        },
        /**
         * Get run info by ID
         *
         * @summary Get run info by ID
         * @param {string} project_id ID of project
         * @param {number} run_id ID of run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunById(project_id: string, run_id: number, options?: any) {
            return RunsApiFp(configuration).getRunById(project_id, run_id, options)(fetch, basePath);
        },
        /**
         * Update test-run info by ID
         *
         * @summary Update test-run info
         * @param {string} project_id ID of project
         * @param {number} run_id ID of run
         * @param {TestrunUpdateRunDto} body Update Run Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunById(project_id: string, run_id: number, body: TestrunUpdateRunDto, options?: any) {
            return RunsApiFp(configuration).updateRunById(project_id, run_id, body, options)(fetch, basePath);
        },
    };
};

/**
 * RunsApi - object-oriented interface
 *
 * @export
 * @class RunsApi
 * @extends {BaseAPI}
 */
export class RunsApi extends BaseAPI {
    /**
     * Close test run
     *
     * @summary Close test run
     * @param {string} project_id ID of project
     * @param {number} run_id ID of run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public closeRunById(project_id: string, run_id: number, options?: any) {
        return RunsApiFp(this.configuration).closeRunById(project_id, run_id, options)(this.fetch, this.basePath);
    }

    /**
     * Create test run
     *
     * @summary Create test run
     * @param {string} project_id ID of project
     * @param {TestrunCreateTestRunDto} body Close Run Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public createRun(project_id: string, body: TestrunCreateTestRunDto, options?: any) {
        return RunsApiFp(this.configuration).createRun(project_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Get list of test-run by projectID
     *
     * @summary Get list of test-run
     * @param {string} project_id ID of project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public getAllRunsByProjectId(project_id: string, options?: any) {
        return RunsApiFp(this.configuration).getAllRunsByProjectId(project_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get run info by ID
     *
     * @summary Get run info by ID
     * @param {string} project_id ID of project
     * @param {number} run_id ID of run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public getRunById(project_id: string, run_id: number, options?: any) {
        return RunsApiFp(this.configuration).getRunById(project_id, run_id, options)(this.fetch, this.basePath);
    }

    /**
     * Update test-run info by ID
     *
     * @summary Update test-run info
     * @param {string} project_id ID of project
     * @param {number} run_id ID of run
     * @param {TestrunUpdateRunDto} body Update Run Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public updateRunById(project_id: string, run_id: number, body: TestrunUpdateRunDto, options?: any) {
        return RunsApiFp(this.configuration).updateRunById(project_id, run_id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * TestsApi - fetch parameter creator
 *
 * @export
 */
export const TestsApiFetchParamCreator = function(configuration?: Configuration) {
    return {
        /**
         * Create test by caseID
         *
         * @summary Create test in run
         * @param {number} project_id ID of project
         * @param {number} run_id ID of run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestByCaseId(project_id: string, run_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'project_id' is not null or undefined
            if (project_id === null || project_id === undefined) {
                throw new RequiredError('project_id','Required parameter project_id was null or undefined when calling createTestByCaseId.');
            }
            // verify required parameter 'run_id' is not null or undefined
            if (run_id === null || run_id === undefined) {
                throw new RequiredError('run_id','Required parameter run_id was null or undefined when calling createTestByCaseId.');
            }
            const localVarPath = '/projects/{project_id}/runs/{run_id}/tests'
                .replace(`{${'project_id'}}`, encodeURIComponent(String(project_id)))
                .replace(`{${'run_id'}}`, encodeURIComponent(String(run_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tests list by RunId
         *
         * @summary Get list of tests in test run
         * @param {number} run_id ID of run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsListByRunId(run_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'run_id' is not null or undefined
            if (run_id === null || run_id === undefined) {
                throw new RequiredError('run_id','Required parameter run_id was null or undefined when calling getTestsListByRunId.');
            }
            const localVarPath = '/projects/{project_id}/runs/{run_id}/tests'
                .replace(`{${'run_id'}}`, encodeURIComponent(String(run_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * TestsApi - functional programming interface
 *
 * @export
 */
export const TestsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create test by caseID
         *
         * @summary Create test in run
         * @param {number} project_id ID of project
         * @param {number} run_id ID of run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestByCaseId(project_id: string, run_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExecutionExecution> {
            const localVarFetchArgs = TestsApiFetchParamCreator(configuration).createTestByCaseId(project_id, run_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get tests list by RunId
         *
         * @summary Get list of tests in test run
         * @param {number} run_id ID of run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsListByRunId(run_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExecutionExecution[]> {
            const localVarFetchArgs = TestsApiFetchParamCreator(configuration).getTestsListByRunId(run_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    };
};

/**
 * TestsApi - factory interface
 *
 * @export
 */
export const TestsApiFactory = function(configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create test by caseID
         *
         * @summary Create test in run
         * @param {number} project_id ID of project
         * @param {number} run_id ID of run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestByCaseId(project_id: string, run_id: number, options?: any) {
            return TestsApiFp(configuration).createTestByCaseId(project_id, run_id, options)(fetch, basePath);
        },
        /**
         * Get tests list by RunId
         *
         * @summary Get list of tests in test run
         * @param {number} run_id ID of run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsListByRunId(run_id: number, options?: any) {
            return TestsApiFp(configuration).getTestsListByRunId(run_id, options)(fetch, basePath);
        },
    };
};

/**
 * TestsApi - object-oriented interface
 *
 * @export
 * @class TestsApi
 * @extends {BaseAPI}
 */
export class TestsApi extends BaseAPI {
    /**
     * Create test by caseID
     *
     * @summary Create test in run
     * @param {number} project_id ID of project
     * @param {number} run_id ID of run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public createTestByCaseId(project_id: string, run_id: number, options?: any) {
        return TestsApiFp(this.configuration).createTestByCaseId(project_id, run_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get tests list by RunId
     *
     * @summary Get list of tests in test run
     * @param {number} run_id ID of run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTestsListByRunId(run_id: number, options?: any) {
        return TestsApiFp(this.configuration).getTestsListByRunId(run_id, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 *
 * @export
 */
export const UsersApiFetchParamCreator = function(configuration?: Configuration) {
    return {
        /**
         * Get current user info
         *
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        user(options: any = {}): FetchArgs {
            const localVarPath = '/users';
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user info by ID
         *
         * @summary Get user by ID
         * @param {number} user_id ID of user to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userById(user_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling userById.');
            }
            const localVarPath = '/users/{user_id}'
                .replace(`{${'user_id'}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('Authorization')
                    : configuration.apiKey;
                localVarHeaderParameter.Authorization = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * UsersApi - functional programming interface
 *
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get current user info
         *
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        user(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).user(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get user info by ID
         *
         * @summary Get user by ID
         * @param {number} user_id ID of user to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userById(user_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userById(user_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    };
};

/**
 * UsersApi - factory interface
 *
 * @export
 */
export const UsersApiFactory = function(configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get current user info
         *
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        user(options?: any) {
            return UsersApiFp(configuration).user(options)(fetch, basePath);
        },
        /**
         * Get user info by ID
         *
         * @summary Get user by ID
         * @param {number} user_id ID of user to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userById(user_id: number, options?: any) {
            return UsersApiFp(configuration).userById(user_id, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 *
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Get current user info
     *
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public user(options?: any) {
        return UsersApiFp(this.configuration).user(options)(this.fetch, this.basePath);
    }

    /**
     * Get user info by ID
     *
     * @summary Get user by ID
     * @param {number} user_id ID of user to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userById(user_id: number, options?: any) {
        return UsersApiFp(this.configuration).userById(user_id, options)(this.fetch, this.basePath);
    }

}

